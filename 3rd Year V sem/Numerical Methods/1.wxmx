 -->	f(x) := x^3 - x - 2;
	
	/* Bisection Method */
	bisection(f, a, b, tol) := block(
	    [c],
	    if f(a) * f(b) > 0 then error("f(a) and f(b) must have opposite signs"),
	    while abs(b - a) > tol do (
	        c: (a + b) / 2,
	        print("a: ", a, " b: ", b, " c: ", c, " f(c): ", f(c)),
	        if f(c) = 0 then return(c),
	        if f(a) * f(c) < 0 then b: c else a: c
	    ),
	    return((a + b) / 2)
	);
	
	/* Example Usage */
	root: bisection(f, 1, 2, 1e-6);
	print("Root: ", root);
 -->	f(x) := x^3 - x - 2;
	
	/* Secant Method */
	secant(f, x0, x1, tol) := block(
	    [x2],
	    while abs(x1 - x0) > tol do (
	        x2: x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0)),
	        print("x0: ", x0, " x1: ", x1, " x2: ", x2, " f(x2): ", f(x2)),
	        x0: x1,
	        x1: x2
	    ),
	    return(x1)
	);
	
	/* Example Usage */
	root: secant(f, 1, 2, 1e-6);
	print("Root: ", root);
	
 -->	f(x) := x^3 - x - 2;
	
	/* Regula Falsi Method */
	regula_falsi(f, a, b, tol) := block(
	    [c],
	    if f(a) * f(b) > 0 then error("f(a) and f(b) must have opposite signs"),
	    while abs(b - a) > tol do (
	        c: a - f(a) * (b - a) / (f(b) - f(a)), /* Compute the false position */
	        print("a: ", a, " b: ", b, " c: ", c, " f(c): ", f(c)),
	        if f(c) = 0 then return(c), /* Exact root found */
	        if f(a) * f(c) < 0 then b: c else a: c /* Narrow the interval */
	    ),
	    return(c)
	);
	
	/* Example Usage */
	root: regula_falsi(f, 1, 2, 1e-6);
	print("Root: ", root);
	
 -->	f(x) := x^3 - x - 2;
	f_prime(x) := 3*x^2 - 1;
	
	/* Newton-Raphson Method */
	newton_raphson(f, f_prime, x0, tol) := block(
	    [x1],
	    x1: x0 - f(x0) / f_prime(x0), /* Initial guess */
	    while abs(f(x1)) > tol do (
	        print("x0: ", x0, " x1: ", x1, " f(x1): ", f(x1)),
	        x0: x1,
	        x1: x0 - f(x0) / f_prime(x0) /* Update using Newton-Raphson formula */
	    ),
	    return(x1)
	);
	
	/* Example Usage */
	root: newton_raphson(f, f_prime, 1, 1e-6);
	print("Root: ", root);
	
 -->	/* Gauss-Jacobi Method */
	gauss_jacobi(A, b, x0, tol, max_iter) := block(
	    [n, x, x_new, i, j, sum, err, iter], 
	    
	    n: length(b), 
	    x: x0,
	    iter: 0,
	    
	    while iter < max_iter do (
	    
	        x_new: makelist(0, i, 1, n), 
	        for i: 1 thru n do (
	            sum: 0,
	            
	            for j: 1 thru n do (
	                if i # j then sum: sum + A[i][j] * x[j]
	            ),
	            
	            x_new[i]: (b[i] - sum) / A[i][i]
	        ),
	        
	
	        err: max(map(lambda([v, v_new], abs(v - v_new)), x, x_new)), 
	        
	
	        print("Iteration: ", iter + 1, " x_new: ", x_new, " Error: ", err),
	
	        if err < tol then return(x_new),
	        x: x_new,
	        iter: iter + 1
	    ),
	    
	    return("Solution did not converge within the maximum iterations.")
	);
	
	/* Example Usage */
	A: matrix([4, -1, 0, 0], [-1, 4, -1, 0], [0, -1, 4, -1], [0, 0, -1, 3]);
	b: [15, 10, 10, 10];
	x0: [0, 0, 0, 0]; /* Initial guess */
	tol: 1e-6;
	max_iter: 100;
	
	root: gauss_jacobi(A, b, x0, tol, max_iter);
	print("Root: ", root);
 -->	/* Gauss-Seidel Method */
	gauss_seidel(A, b, x0, tol, max_iter) := block(
	    [n, x, i, j, sum, err, iter],
	    
	    /* Ensure the matrix A and vector b are correctly defined */
	    n: length(b), /* Number of variables */
	    
	    /* Initial guess */
	    x: x0,
	    
	    /* Initialize error and iteration counter */
	    iter: 0,
	    
	    /* Start iterations */
	    while iter < max_iter do (
	        
	        /* Loop over each equation */
	        for i: 1 thru n do (
	            sum: 0,
	            
	            /* Sum over all previous variables (with updated values) */
	            for j: 1 thru n do (
	                if i # j then sum: sum + A[i][j] * x[j]
	            ),
	            
	            /* Update the value for the current variable */
	            x[i]: (b[i] - sum) / A[i][i]
	        ),
	        
	        /* Compute the error as the maximum difference between old and new values */
	        err: max(map(lambda([v, v_new], abs(v - v_new)), x0, x)),  /* Renamed error to err */
	        
	        /* Print intermediate results */
	        print("Iteration: ", iter + 1, " x: ", x, " Error: ", err),
	        
	        /* Check if error is within the tolerance */
	        if err < tol then return(x), /* Converged */
	        
	        /* Update x0 for the next iteration */
	        x0: x,
	        
	        /* Increment iteration counter */
	        iter: iter + 1
	    ),
	    
	    return("Solution did not converge within the maximum iterations.")
	);
	
	/* Example Usage */
	A: matrix([4, -1, 0, 0], [-1, 4, -1, 0], [0, -1, 4, -1], [0, 0, -1, 3]);
	b: [15, 10, 10, 10];
	x0: [0, 0, 0, 0]; /* Initial guess */
	tol: 1e-6;
	max_iter: 100;
	
	root: gauss_seidel(A, b, x0, tol, max_iter);
	print("Root: ", root);
	
 -->	lagrange_interpolation(x_vals, y_vals) := block(
	    [n, L, P, x, i, j],
	    n: length(x_vals), 
	    P: 0,
	
	    for i: 1 thru n do (
	        L: 1,  
	        
	        for j: 1 thru n do (
	            if i # j then L: L * (x - x_vals[j]) / (x_vals[i] - x_vals[j])
	        ),
	        
	        P: P + y_vals[i] * L
	    ),
	    
	    return(P)
	);
	
	/* Example Usage */
	x_vals: [1, 2, 3]; 
	y_vals: [2, 3, 5]; 
	P: lagrange_interpolation(x_vals, y_vals);
	
	evaluated_value: subst(x=1.5, P);  
	print("P(1.5) = ", evaluated_value);
 -->	/* Define function for divided difference */
	divided_difference(x_values, y_values) := block(
	    [n: length(x_values), dd: []],
	    /* Initialize the divided difference table */
	    dd: makelist(y_values[i], i, 1, n),
	    for i: 2 thru n do (
	        for j: n step -1 thru i do (
	            dd[j]: (dd[j] - dd[j-1]) / (x_values[j] - x_values[j-i+1])
	        )
	    ),
	    return(dd)
	);
	
	/* Define function for Newton Polynomial */
	newton_polynomial(x_values, dd, x) := block(
	    [n: length(x_values), poly: dd[1], term: 1],
	    for i: 2 thru n do (
	        term: term * (x - x_values[i-1]),
	        poly: poly + dd[i] * term
	    ),
	    return(expand(poly))
	);
	
	/* Input x_values and y_values */
	x_values: [1, 2, 4, 7];
	y_values: [1, 4, 16, 49];
	
	/* Calculate divided differences */
	dd: divided_difference(x_values, y_values);
	
	/* Generate Newton Polynomial */
	newton_poly: newton_polynomial(x_values, dd, x);
	
	/* Output */
	print("Divided Differences: ", dd);
	print("Newton Polynomial: ", newton_poly);
	
 -->	trapezoidal_rule(f, a, b, n) := block(
	    [h, sum, i, x],
	    h: (b - a) / n,  
	    sum: f(a) + f(b), 
	    
	    for i: 1 thru n-1 do (
	        sum: sum + 2 * f(a + i * h)
	    ),
	    
	    return(h * sum / 2)
	);
	
	f(x) := x^2; 
	a: 0;  
	b: 1;  
	n: 4; 
	
	result: trapezoidal_rule(f, a, b, n);
	print("Trapezoidal Rule Result: ", result);
 -->	simpsons_rule(f, a, b, n) := block(
	    [h, sum_even, sum_odd, i, x],
	    h: (b - a) / n, 
	    sum_even: 0,  
	    sum_odd: 0,  
	    
	      for i: 1 step 2 thru n-1 do (
	        sum_odd: sum_odd + f(a + i * h)
	    ),
	        
	    for i: 2 step 2 thru n-2 do (
	        sum_even: sum_even + f(a + i * h)
	    ),
	    return(h / 3 * (f(a) + 4 * sum_odd + 2 * sum_even + f(b)))
	);
	
	/* Example Usage */
	f(x) := x^2;  
	a: 0;  
	b: 1;  
	n: 4;  
	
	result_simpson: simpsons_rule(f, a, b, n);
	print("Simpson's Rule Result: ", result_simpson);
 -->	/* Function for Euler's Method */
	euler_method(f, x0, y0, h, x_end) := block(
	    [x: x0, y: y0, steps: floor((x_end - x0) / h), results: []],
	    results: cons([x, y], results),
	    for i: 1 thru steps do (
	        y: y + h * ev(f, [x = x, y = y]),
	        x: x + h,
	        results: cons([x, y], results)
	    ),
	    return(reverse(results))
	);
	
	/* Function for Runge-Kutta 4th Order Method */
	rk4_method(f, x0, y0, h, x_end) := block(
	    [x: x0, y: y0, steps: floor((x_end - x0) / h), results: []],
	    results: cons([x, y], results),
	    for i: 1 thru steps do (
	        k1: h * ev(f, [x = x, y = y]),
	        k2: h * ev(f, [x = x + h / 2, y = y + k1 / 2]),
	        k3: h * ev(f, [x = x + h / 2, y = y + k2 / 2]),
	        k4: h * ev(f, [x = x + h, y = y + k3]),
	        y: y + (k1 + 2 * k2 + 2 * k3 + k4) / 6,
	        x: x + h,
	        results: cons([x, y], results)
	    ),
	    return(reverse(results))
	);
	
	/* Example Problem: dy/dx = x + y, y(0) = 1 */
	f: x + y;
	x0: 0; /* Initial x */
	y0: 1; /* Initial y */
	h: 0.1; /* Step size */
	x_end: 1; /* Final x */
	
	/* Solve using Euler's Method */
	euler_results: euler_method(f, x0, y0, h, x_end);
	print("Euler's Method Results: ", euler_results);
	
	/* Solve using Runge-Kutta Method */
	rk4_results: rk4_method(f, x0, y0, h, x_end);
	print("Runge-Kutta 4th Order Results: ", rk4_results);
	
